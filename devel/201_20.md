# [201_20] 修复大范围复制的数组越界崩溃

## 2025/09/10 修复大范围复制的数组越界崩溃

### What

当正在编辑的文档较大时，`<Ctrl-a>` 全选复制很容易触发卡死或崩溃。
本次变更修复了该问题。

### Why

修复没有按预期工作的功能。

### 详细描述和解决

#### 表现

在 Windows 上使用 STEM 软件，当选择较大范围的结构时，按快捷键复制有概率会失败，表现为

1. 剪贴板没有被成功设置内容
2. 日志报 C++ backtrace

此时保持选择范围不变，继续按快捷键复制就会崩溃。

#### 原因

问题根源在于，在原实现中，复制操作时传递给解码函数（e.g. `FromUtf8`）的长度参数不正确。
以 UTF8 编码路径为例，最终调用处在：[src/Plugins/Qt/qt_gui.cpp#L401](https://gitee.com/XmacsLabs/mogan/blob/21d29eaac6c825a95da6d58f7c5a662015d17094/src/Plugins/Qt/qt_gui.cpp#L401)
简化如下：
```cpp
bool
qt_gui_rep::set_selection (string key, tree t, string s, string sv, string sh,
                           string format) {
  // ...
  // 第一次声明 & 赋值
  c_string selection (s);
  if (format == "verbatim" || format == "default") {
    if (format == "default") {
      md->setData ("application/x-texmacs-clipboard", (char*) selection);
      (void) sh;
      // 重赋值处
      selection= c_string (sv);
    }
    // ...
    if (enc == "utf-8" || enc == "UTF-8")
      // 这里是最终调用解码函数的地方
      md->setText (QString::fromUtf8 (selection, N (s)));
    // else other encodings ...
  }
  // ...
}
```

观察函数 `qt_gui_rep::set_selection`，能够注意到，当 `format` 参数为 `default` 时，`selection` 被重新赋值为了 `c_string (sv)`，而在传递参数给 `fromUtf8` 的时候，其第二个参数 `size` 仍然被传递了 `s` 的长度。

```cpp
QString QString::fromUtf8(const char *str, qsizetype size)

Returns a QString initialized with the first size bytes of the UTF-8 string str.

If size is -1, strlen(str) is used instead.
```

由于这里的 `s` 是结构化的文本，`sv` 是扁平后的纯文本，`s` 总是比 `sv` 更长。因此这里得到的 `QString` 总是会访问到 `selection` 数据范围外的数据，也正因如此，当数据足够大，越界访问触及到了无效内存，就导致了程序崩溃。

#### 检查行为

在上面的分析中，能够得到一个结论：复制任意结构，都会在正常的纯文本后跟随一些乱码。
其中正常的纯文本是 `selection`，即 `sc` 的内容，后面跟随的乱码为 `selection[N(s) - strlen(selection)]`，这里访问的内存并非 `selection` 持有的，即越界访问，由此产生乱码（随机内存不太可能是合法的 UTF-8）。

在编辑器中验证该结论，可以发现结论匹配。

#### 如何修复

修复方法是解码时不再指定固定长度，而是让解码函数自动以 `\0` 结尾作为终止（`strlen`）。具体做法是将 `QString::FromEnc` 的第二个参数 size 设置为 `-1`，确保只读取有效内容，避免越界。这样即使 `selection` 被重新赋值，也不会因长度参数错误导致异常。

能够这样修复，是由于 `selection` 的类型 `c_string` 是 C-style 字符串 `const char*` 的薄包装，见 [3rdparty/lolly/Kernel/Types/string.hpp#L131](https://gitee.com/XmacsLabs/mogan/blob/21d29eaac6c825a95da6d58f7c5a662015d17094/3rdparty/lolly/Kernel/Types/string.hpp#L131)。

#### 为什么只有 Windows 有问题？

猜测：Linux 上的堆实现（如 glibc malloc）在分配块之间可能因对齐或元数据管理而存在未使用空间，导致越界访问更不容易立即触发崩溃。而 MSVC 的堆管理更严格，越界访问更容易触及受保护的内存区域，从而直接导致程序崩溃。
