# 201_7
## 如何测试
### 测试切换/关闭标签页
1. 打开STEM，自带一个窗口，下面称为W1。自带一个buffer，下面称为A1
2. cmd-n创建一个新的buffer，下面称为B1
3. 标签页栏里面，点击A1.
4. 检查：切换到A1标签页
5. cmd-w关闭A1
6. 检查：A1被关闭，自动attach到B1
7. cmd-shift-n创建一个新的窗口，下面称为W2。新的窗口自带一个新的buffer，下面称为A2
8. cmd-w关闭A2
9. 检查：A2、W2都被关闭
10. 在B1中进行一些编辑操作（可以粘贴一段文档），以等待shedule_destruction被触发。
11. 检查：没有crash（先前在这个位置出过段错误，已被修复）

### 测试Go菜单切换标签页
1. 打开STEM，cmd-n创建一个新的buffer。现在我们有两个buffer，下面称为A和B
2. Go->buffer A
3. Go->buffer B
4. Go->buffer A
5. 检查：view被正常attach了

### 测试Go菜单跨窗口切换标签页
1. 打开STEM，自带一个窗口，下面称为W1。自带一个buffer，下面称为A1
2. cmd-n创建一个新的buffer，下面称为B1
3. cmd-shift-n创建一个新的窗口，下面称为W2。新的窗口自带一个新的buffer，下面称为A2
4. cmd-n创建一个新的buffer，下面称为B2
5. 在W2的菜单栏中，点击Go
5. 检查：可用的buffer，应当为A1、A2、B1、B2。其中B2为打勾状态
6. 在W2的菜单栏中，Go->A1
7. 检查：窗口切换到W1，且标签页切换到A1

### 测试标签页切换所在窗口的后端接口
1. 打开STEM，自带一个窗口，下面称为W1。自带一个buffer，下面称为A1。
2. cmd-n创建一个新的buffer，下面称为B1
3. cmd-shift-n创建一个新的窗口，下面称为W2。新的窗口自带一个新的buffer，下面称为A2
4. cmd-n创建一个新的buffer，下面称为B2
4. cmd-n创建一个新的buffer，下面称为C2
5. 在C2中，插入一个Scheme块
```
(view-set-window (current-view) (list-ref (window-list) 0) #t )
```
6. 运行这个语句。
7. 检查：C2进入了W1。窗口和编辑器焦点也切换到了W1
8. 重新切换回W2
5. 在B2中，插入一个Scheme块
```
(view-set-window (current-view) (list-ref (window-list) 0) #f )
```
6. 运行这个语句。
7. 检查：B2进入了W1。窗口和编辑器焦点留在W2
5. 在A2中，插入一个Scheme块
```
(view-set-window (current-view) (list-ref (window-list) 0) #t )
```
6. 运行这个语句。
7. 检查：A2进入了W1, W2关闭
5. 在A2中，插入一个Scheme块
```
(view-set-new-window (current-view))
```
6. 运行这个语句。
7. 检查：A2进入了新的窗口中

### 测试标签页切换所在窗口的前端实现
注意：请先阅读“标签页切换所在窗口的前端实现”的已知问题
1. 自由地使用cmd-n、cmd-shift-n创建窗口和buffer
2. 自由地拖动标签页到不同的标签栏之内.
3. 检查：标签页被拖入另一个窗口的标签栏时是否显示了灰色竖线
4. 检查: 标签页的脱离和吸附是否符合预期
5. 自由地拖动标签页到标签栏上方。
6. 检查：标签页是否正常单独分离成为窗口

### 测试多窗口打开相同的buffer
1. 打开STEM，自带一个窗口，下面称为W1。自带一个buffer，下面称为A1
2. cmd-o，打开一个文档，下面称为B1.tmu
3. 再次cmd-o打开B1.tmu
4. 检查: B1.tmu没有被打开两个标签页
5. 切换到A1，再次cmd-o打开B1.tmu
6. 检查：B1.tmu没有被打开两个标签页，且当前标签页切换到B1
4. cmd-shift-n，打开新的窗口，下面称为W2
5. cmd-o，打开B1.tmu
6. 检查：B1.tmu作为新的buffer在W2中出现
7. cmd-w，关闭W2中的B1.tmu
8. 检查：W2中的B1.tmu关闭，W1中的B1.tmu没有影响

### 测试同一Buffer打开多个标签页时的选中显示
1. 准备一个tmu文档A.tmu
2. 打开A.tmu，然后cmd-o再次打开A.tmu
3. 检查：标签栏中有两个A.tmu
4. 使用鼠标或者键盘在两个A.tmu中切换
5. 检查：两个A.tmu中只有一个可以被选中，不会出现两个标签页被同时选中的情况

## 2025/08/04 fix: 同一Buffer打开多个标签页时选中显示问题
### What
修改了构造标签页 UI 时对 active? 的定义，使用 `current-view` 替代 `current-buffer`。这可以使得同一Buffer打开多个标签页时，分别被选中。

## 2025/08/04 同窗口打开相同buffer时优先切换到现存的标签页
### What
修改了`load-buffer-open`中的逻辑，在尝试打开与**当前窗口**现存的标签页的buffer相同的buffer时，优先切换到当前窗口现存的标签页。在尝试打开与**当前窗口**现存的标签页的buffer都不相同的buffer时，创建新的标签页。（也就是说，允许相同的buffer出现在不同的窗口中，允许用户将相同的buffer拖拽到相同的窗口中，但是在用户不手动拖拽的情况下不允许相同的buffer存在于同一个窗口中）

## 2025/07/25 标签页切换所在窗口的前端实现
### What
- 新功能：现在可以通过拖拽的方式切换标签页所在的窗口
- 给 view_set_window 添加了返回值。

```
ret_type = "bool", -- 是否释放了目标 view 所在的 window
```

这是因为view_set_window中可能执行kill_window的操作，造成悬垂指针的隐患。

### 已知问题
- 排序的适配还没有做，所以切换窗口后Tab标签的拖拽排序功能是乱的。

## 2025/07/24 标签页切换所在窗口的后端实现与接口
### What
添加了函数view_set_window与其接口。具体用法见basic_glue.lua接口处的注释
添加了函数view_set_new_window与其接口。具体用法见basic_glue.lua接口处的注释
```
{
    -- 设定标签页（view）所在的窗口
    scm_name = "view-set-window",
    cpp_name = "view_set_window",
    ret_type = "bool", -- 是否释放了目标 view 所在的 window
    arg_list = {
        "url", -- 目标 view 的 url
        "url", -- 目标 window 的 url。传入 url-none 时打开新窗口。
        "bool" -- 是否设置为焦点
               --    输入 true 时，将目标窗口所附着的的 view 切换为目标 view，
               --    且将目标窗口提升到顶部。
               --    输入 false 时，不改变目标窗口所附着的 view。且不将目标窗
               --    口提升到顶部。
    }
},
{
    -- 将标签页（view）挪动到新窗口
    scm_name = "view-set-new-window",
    cpp_name = "view_set_new_window",
    ret_type = "void",
    arg_list = {
        "url", -- 目标 view 的 url
    }
},
```

### Why
为以后实现类似Chrome的Attach和Detach做准备。

### 已知问题
- TabBar的刷新具有滞后性，导致切换窗口后Tab标签仍然留了下来。这个多余的标签会在下一次刷新消失。
- 排序的适配还没有做，所以切换窗口后Tab标签的拖拽排序功能是乱的。

## 2025/07/16 Go菜单支持多窗口、多标签页
### What
添加Go菜单对多窗口、多标签页的支持。
- 添加了scheme函数buffer->windows-of-tabpage
- 修改了Go菜单的创建逻辑，不筛选current-views
- 修改了switch-to-buffer*的逻辑
  - 当当前窗口存在此buffer时，优先切换到当前窗口的buffer
  - 当当前窗口不存在此buffer时，切换到其他窗口的此buffer

## 2025/07/16 优化get_passive_view_of_tabpage的逻辑
### What?
优化了get_passive_view_of_tabpage中直接返回现存view的条件。添加了else分支以实现在一个view处于detach的且处在当前窗口的标签栏的情况下直接返回该view。

### Why?
先前的逻辑是不完全、会出问题的，由于没有察觉到Go菜单的使用而没注意到。

## 2025/07/11 使用view代替buffer实现标签页的切换和关闭
### What
修改了文档、标签页关闭的逻辑。从以前的kill_buffer修改为新的方法kill_tabpage。现在，所有有关关闭文档的操作都将以标签页为单位，采用kill_tabpage，由kill_tabpage中的逻辑判断是否需要kill_buffer, kill_window。

修改了标签页切换的逻辑，从以前的switch_to_buffer修改为window_set_view。

修改了tabpage-menu.scm中标签页创建的参数，关闭操作绑定到kill_tabpage上，并在创建时筛选当前窗口的标签页。

**PR评论中有对特定行代码的解释：https://gitee.com/XmacsLabs/mogan/pulls/407**


